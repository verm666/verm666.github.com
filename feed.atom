<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Recent Blog Posts</title>
  <id>http://verm666.github.com/feed.atom</id>
  <updated>2012-03-17T00:00:00Z</updated>
  <link href="http://verm666.github.com/" />
  <link href="http://verm666.github.com/feed.atom" rel="self" />
  <subtitle type="text">Recent blog posts</subtitle>
  <generator>Werkzeug</generator>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">Ферма для XXX с хранилищем за день</title>
    <id>http://verm666.github.com/2012/03/17/xxx_farm</id>
    <updated>2012-03-17T00:00:00Z</updated>
    <link href="http://verm666.github.com/2012/03/17/xxx_farm" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;Описание задачи&lt;/h2&gt;
&lt;p&gt;Предоставить сервис, который должен:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Принять запрос от клиента на получение видео файла;&lt;/li&gt;
&lt;li&gt;Получить видео данные в контейнере А от др. сервиса (назовем его L);&lt;/li&gt;
&lt;li&gt;Перепаковать в контейнер B;&lt;/li&gt;
&lt;li&gt;Сохранить полученный файл;&lt;/li&gt;
&lt;li&gt;Отдать полученный файл клиенту;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;При этом:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;При последующих запросах файла - он должен отдаваться без обращения к бэкенду;&lt;/li&gt;
&lt;li&gt;Если на сервис приходит одновременно несколько запросов за одним файлом -
на бэкенд должен уходить только первый, остальные ждут и получают результат первого.&lt;/li&gt;
&lt;li&gt;Должна быть предоставлена возможность перегенерации полученного файла;&lt;/li&gt;
&lt;li&gt;Ссылка на файл должна иметь время ограниченное жизни.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;Размах проблемы&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&amp;gt; 20 000 запросов на изготовление файлов. Каждый размером ~ 100 МБ;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;Оборудование, которое было под руками&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Сервер (далее S) с 32-мя 3ТБ дисками и 3ware RAID контроллером (9xxx серия);&lt;/li&gt;
&lt;li&gt;N серверов с памятью и процессорами (назовем их W) - будут заниматься обработкой видео.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;Полученное решение&lt;/h2&gt;
&lt;div class="section" id="m"&gt;
&lt;h3&gt;Число M&lt;/h3&gt;
&lt;p&gt;Число M - максимальное число W-серверов в ферме. Выбирается один раз и навсегда.
Изменить его потом будет очень сложно. По сути является ограничением
масштабирования нашей фермы. Я взял 64. Красивое число да и W-серверов больше нет.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;Хранилище&lt;/h3&gt;
&lt;p&gt;Первое о чем приходится задуматься - предоставление доступа к S-серверу с
любого W-сервера. При этом хочется иметь POSIX-совместимый доступ к файлам.&lt;/p&gt;
&lt;p&gt;Как ни странно связка XFS + NFS будет работать весьма неплохо. Да, в RW доступе.
Да, сразу на всех W-серверах. Нет, я не ебанулся.&lt;/p&gt;
&lt;p&gt;На самом деле сказанное выше (а именно RW доступ на всех W-серверах) не совсем
верно. Доступ будет, но мы не будем им пользоваться.&lt;/p&gt;
&lt;p&gt;В итоге:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Из всех дисков создаем RAID-6. Получаем 82 ТБ дискового пространства;&lt;/li&gt;
&lt;li&gt;Создаем на базе этого блочного устройства LVM VG;&lt;/li&gt;
&lt;li&gt;Нарезаем на M (смотри выше) LV;&lt;/li&gt;
&lt;li&gt;Создаем на них XFS;&lt;/li&gt;
&lt;li&gt;Монтируем в /storage/video/[1..M];&lt;/li&gt;
&lt;li&gt;Раздаем через NFS всем W-серверам в rw доступе.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;На этом настройка хранилища заканчивается. Больше о нем думать не надо.
Теперь надо просто добиться того, что бы в каждую отдельно взятую
точку монтирования отданную через NFS писал только 1 W-сервер. Этим
будет заниматься Балансер (Nginx).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h3&gt;Балансер&lt;/h3&gt;
&lt;p&gt;Для балансировки запросов к W-серверам и хранилищу будет использоваться Nginx.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;version &amp;gt;= 1.1.13 (из-за cache_lock);&lt;/li&gt;
&lt;li&gt;add ngx_secure_download;&lt;/li&gt;
&lt;li&gt;add ngx_mod_perl.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;На балансере точно так же как и на W-серверах монтируются все Logical Volume-ы
c S-сервера, только в ro режиме, так как писать нам на балансере не надо.&lt;/p&gt;
&lt;p&gt;Сразу приведу итоговый конф. файл, что бы было поянтно о чем я говорю:
&lt;a class="reference external" href="/static/my/xxx_farm_nginx.conf"&gt;nginx.conf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;На nginx приходят запросы вида: /video/uuid/begin-end.mp4/md5sum/hex_ts, где&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;uuid - некий ID, является идентификатором для обращения к сервису L;&lt;/li&gt;
&lt;li&gt;begin - timestamp начала получаемого файла;&lt;/li&gt;
&lt;li&gt;end - timestamp конца получаемого файла;&lt;/li&gt;
&lt;li&gt;md5sum/hex_ts - кусочки от ngx_secure_download.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;И так, пойдем по порядку:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Ограничение времени жизни ссылки на скачивание достигается через
ngx_secure_download;&lt;/li&gt;
&lt;li&gt;Балансировку между W-серверами и Logical Volume-ами S-сервера будет за нас
делать mod_perl, &lt;a class="reference external" href="http://www.cse.yorku.ca/~oz/hash.html"&gt;djb2&lt;/a&gt; и число M.
Таким образом запрос по конкретному uuid всегда будет уходить
на один и тот же W-сервер (см. map $shard $backend).
Итоговый файл для этого uuid всегда будет записываться в один и тот же
Logical Volume на S-сервере и запись в него будет производить только
один W-сервер.&lt;/li&gt;
&lt;li&gt;Удерживать одинаковые запросы к бэкенду будет cache_lock (если бы эта директива
не появилась в последних релизах - пришлось бы добавить еще Varnish. Так как до
недавнего времени именно этот кэш-сервер умел это делать);&lt;/li&gt;
&lt;li&gt;Возможность пересоздать файл предоставляется через отдельный server на др. порту
(можно было сделать просто отдельный location, но 80-й порт открыт в Internet);&lt;/li&gt;
&lt;li&gt;Отдача ранее сгенерированных файлов - try_files.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;Бэкенд&lt;/h3&gt;
&lt;p&gt;Собстенно это небольшой python (flask + eventlet) сервис, который делает несколько
простых операций:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Забирает файл с сервиса L;&lt;/li&gt;
&lt;li&gt;Перепаковывает в конейнер B;&lt;/li&gt;
&lt;li&gt;Записывает файл в нужный Logical Volume;&lt;/li&gt;
&lt;li&gt;Через X-Accel-Redirect отдает файл в Nginx (см. location /internal_video).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Кстати, ленивые для подобных (или любых других операций) могут воспользоваться
&lt;a class="reference external" href="https://github.com/verm666/joyer"&gt;Joyer&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3&gt;Еще пара слов про масшабирование&lt;/h3&gt;
&lt;p&gt;Добавление нового W-сервера приводит к тому, что мы добавляем его в
map $shard $backend. Равномерно распределяя shard-ы по бэкендам.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h2&gt;Выводы&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Если у вас есть возможность что-то вынести в mod_perl в Nginx - это
стоит сделать (сходить в memcache, посмотреть в cookie или как в этом случае -
получить возможность однозначной балансировки от некоторой переменной);&lt;/li&gt;
&lt;li&gt;Если включать мозг - наличие NFS в проекте не всегда плохо.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h2&gt;Литература по теме&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Nginx Secure Download - &lt;a class="reference external" href="http://wiki.nginx.org/HttpSecureDownload"&gt;http://wiki.nginx.org/HttpSecureDownload&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Message Authentication Code - &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Message_authentication_code"&gt;http://en.wikipedia.org/wiki/Message_authentication_code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;djb2 - &lt;a class="reference external" href="http://www.cse.yorku.ca/~oz/hash.html"&gt;http://www.cse.yorku.ca/~oz/hash.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Nginx cache_lock - &lt;a class="reference external" href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_lock"&gt;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_lock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;nginx.conf - &lt;a class="reference external" href="http://verm666.name/static/my/xxx_farm_nginx.conf"&gt;http://verm666.name/static/my/xxx_farm_nginx.conf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;joyer - &lt;a class="reference external" href="https://github.com/verm666/joyer"&gt;https://github.com/verm666/joyer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="p-s"&gt;
&lt;h2&gt;P.S.&lt;/h2&gt;
&lt;p&gt;XXX - это не значит, что решение используется в сфере связанной с порнографией ;).&lt;/p&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">Приватный репозиторий OBS</title>
    <id>http://verm666.github.com/2012/01/15/stand_alone_OBS</id>
    <updated>2012-01-15T00:00:00Z</updated>
    <link href="http://verm666.github.com/2012/01/15/stand_alone_OBS" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;Вступление&lt;/h2&gt;
&lt;p&gt;После того, как в субботу вечером в очередной раз build.opensuse.org лег и начал
отдавать на все запросы 503 терпение закончилось и было решено отвязаться
от внешнего сервиса окончательно.&lt;/p&gt;
&lt;p&gt;В wiki проекта можно найти несколько упоминаний о том, как это можно сделать. Но
на примере rpm-based дистрибутивов. И ни одного примера для Debian. Ниже будет
описано как это сделать для Debian 6.0 (x86_64).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="forever-alone"&gt;
&lt;h2&gt;Forever alone&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Создаем новый проект в OBS (Debian);&lt;/li&gt;
&lt;li&gt;Создаем в нем подпроект (6:0);&lt;/li&gt;
&lt;li&gt;Вносим изменения в Raw config проекта (Project-&amp;gt;Advanced-&amp;gt;Raw Config);&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;project&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Debian:6.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;6.0&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;description/&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;person&lt;/span&gt; &lt;span class="na"&gt;role=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;maintainer&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;userid=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;verm666&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;person&lt;/span&gt; &lt;span class="na"&gt;role=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bugowner&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;userid=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;verm666&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;repository&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;standard&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;arch&amp;gt;&lt;/span&gt;x86_64&lt;span class="nt"&gt;&amp;lt;/arch&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Заливаем projconf (Projct-&amp;gt;Advanced-&amp;gt;Project Config);&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Именно из-за этого пункта я пишу эту заметку. Т.к. готового конфига в rpm
пакетах OBS нет (если для Lenny, но он немного не работает),
а при лежащем build.opensuse.org искать его, по факту, негде.&lt;/p&gt;
&lt;p&gt;Мой projconf для Debian_6.0 можно взять &lt;a class="reference external" href="/static/my/Debian_6.0_prjconf.txt"&gt;тут&lt;/a&gt;.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Заходим на сервер по ssh и создаем директорию для бинарных пакетов нашего проекта:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# mkdir -p /srv/obs/build/Debian\:6.0/standard/x86_64/\:full/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Кладем в эту директорию все пакеты для Debian Squeeze x86_64
(я использовал debmirror);&lt;/p&gt;
&lt;p&gt;Индексируем проект:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# /usr/lib/obs/server/bs_admin --rescan-repository Debian:6.0 standard x86_64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Смотрим логи obsscheduler'а:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# tail -f /srv/obs/log/scheduler_x86_64.log
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;Сборка пакетов&lt;/h2&gt;
&lt;p&gt;Для сборки своих пакетов создается отдельный репозиторий и подключается как
build target через advanced interface (Or pick one via advanced interface. На
странице с репозиториями проекта)&lt;/p&gt;
&lt;p&gt;Hint: В 'New name' лучше указывать Debian_6.0 (такое же название, какое
используется при работе с внешним OBS. Таким образом после отключения внешнего
OBS ссылки на репозиторий с deb пакетами останутся прежними и вам не придется
вносить изменения в sources.list)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;Ссылки по теме&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://en.opensuse.org/openSUSE:Build_Service_prjconf"&gt;http://en.opensuse.org/openSUSE:Build_Service_prjconf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://en.opensuse.org/openSUSE:Build_Service_adding_build_targets"&gt;http://en.opensuse.org/openSUSE:Build_Service_adding_build_targets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://en.opensuse.org/openSUSE:Build_Service_private_instance_boot_strapping"&gt;http://en.opensuse.org/openSUSE:Build_Service_private_instance_boot_strapping&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">Shebang</title>
    <id>http://verm666.github.com/2011/12/15/shebang</id>
    <updated>2011-12-15T00:00:00Z</updated>
    <link href="http://verm666.github.com/2011/12/15/shebang" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;p&gt;В комлекте с ixgbe-3.9.2 идет небольшой скрипт, раскидывающий прерывания по
ядрам, но речь сейчас не о affinity.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% head -2 scripts/set_irq_affinity.sh
# setting up irq affinity according to /proc/interrupts
# 2008-11-25 Robert Olsson
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Вот так выглядят первые две строчки скрипта. Запускаем руками в консоли -
все хорошо. Без задней мысли дописываем в /etc/network/interfaces&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;...
up /etc/network/set_irq_affinity.sh eth0
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;и теряем сервер.&lt;/p&gt;
&lt;p&gt;Причина банальна - скрипт запускается в sh, который в debian squeeze является
символической ссылкой на dash. На 32 строке скрипта:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;...
for ((i=1; i&amp;lt;=$IDX;i++)))
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;скрипт завершается с ошибкой &lt;strong&gt;Syntax error: Bad for loop variable&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;Выводы&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Товарищи из Intel могли бы и подумать;&lt;/li&gt;
&lt;li&gt;Никому нельзя верить и все надо проверять.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="p-s"&gt;
&lt;h2&gt;p.s.&lt;/h2&gt;
&lt;p&gt;Да, сервер еще не был в production и паника немного не уместна, но печально.&lt;/p&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">Goblr</title>
    <id>http://verm666.github.com/2011/10/13/goblr</id>
    <updated>2011-10-13T00:00:00Z</updated>
    <link href="http://verm666.github.com/2011/10/13/goblr" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;p&gt;Goblr (&lt;strong&gt;G&lt;/strong&gt;ithub/&lt;strong&gt;G&lt;/strong&gt;itorious to &lt;strong&gt;OB&lt;/strong&gt;S &lt;strong&gt;L&lt;/strong&gt;ightweight &lt;strong&gt;R&lt;/strong&gt;outer) - небольшой сервис
занимающийся интеграцией git хостингов и openSUSE Build Service.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Домашная страница проекта: &lt;a class="reference external" href="https://github.com/verm666/goblr"&gt;https://github.com/verm666/goblr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wiki проекта: &lt;a class="reference external" href="https://github.com/verm666/goblr/wiki"&gt;https://github.com/verm666/goblr/wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Публичная инсталляция: &lt;a class="reference external" href="http://goblr.verm666.name"&gt;http://goblr.verm666.name&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">Supervisord</title>
    <id>http://verm666.github.com/2011/10/07/supervisord</id>
    <updated>2011-10-07T00:00:00Z</updated>
    <link href="http://verm666.github.com/2011/10/07/supervisord" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;Введение&lt;/h2&gt;
&lt;p&gt;Supervisord - еще один из (кроме runit, launchd, systemd, upstart и т.п.) продуктов
занимающихся слежением за сервисами, запущенными в виде дочерних процессов.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://supervisord.org"&gt;Официальный сайт&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/supervisor/supervisor"&gt;Guthub репозиторий&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Написан на Python. Для всех операций по управлению сервисами (start/stop/etc) как в web-interface, так
и в supervisorctl использует XML-RPC.&lt;/p&gt;
&lt;p&gt;О том как поставить и запустить сам supervisord можно прочитать на &lt;a class="reference external" href="http://supervisord.org"&gt;сайте проекта&lt;/a&gt;.
Ниже я опишу только те моменты, которые мне показались интересными.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;Добавление нового сервиса&lt;/h2&gt;
&lt;p&gt;Добавление нового сервиса осуществляется через редактирование основного конф. файла (supervisord.conf)
или созданием отдельного конф. файла, который будет подключен через директиву include.
Простой пример конфигурационного файла для демона, который должен быть запущен в двух
экземплярах:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[program:daemon]&lt;/span&gt;
&lt;span class="na"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;vdm&lt;/span&gt;
&lt;span class="na"&gt;command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/opt/bin/daemon-runner&lt;/span&gt;
&lt;span class="na"&gt;process_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;%(program_name)s_%(process_num)02d&lt;/span&gt;
&lt;span class="na"&gt;process_num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;2&lt;/span&gt;
&lt;span class="na"&gt;stdout_logfile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/var/log/%(program_name)s_%(process_num)02d.log&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;На мой взгляд это основная фишка supervisord - возможность запуска нескольких экземпляров демона без лишних телодвижений.
В том же runit для этого пришлось бы создать два отдельных сервиса с идентичными настройками, а в upstart - один сервис
привязанный к событию и нечто, что emit'ит это событие (идеально подходит для конфигурации сетевых интерфейсов,
но вот запуск просто демона получается слишком сложным (см. настройку сетевой подсистемы в Ubuntu)).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;Порядок запуска сервисов&lt;/h2&gt;
&lt;p&gt;После прочтения документации вам может показаться, что в supervisord самая вменяемая реализация порядка запуска сервисов.
Это не так.&lt;/p&gt;
&lt;p&gt;В supervisord каждому сервису можно задать приоритет (priority). Сервис с наивысшим приоритетом включается
последним и выключается первым. Кроме этого для сервиса можно указать параметр startsecs, который указывает
время в секундах, которое сервис должен прожить, что бы считаться успешно запущенным.&lt;/p&gt;
&lt;p&gt;Рассмотрим простой пример:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Конф. файл supervisord:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[program:service1]&lt;/span&gt;
&lt;span class="na"&gt;command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/opt/bin/service1&lt;/span&gt;
&lt;span class="na"&gt;priority&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;1&lt;/span&gt;
&lt;span class="na"&gt;startsecs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;10&lt;/span&gt;
&lt;span class="na"&gt;stdout_logfile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/tmp/service1.log&lt;/span&gt;

&lt;span class="k"&gt;[program:service2]&lt;/span&gt;
&lt;span class="na"&gt;command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/opt/bin/service2&lt;/span&gt;
&lt;span class="na"&gt;priority&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;100&lt;/span&gt;
&lt;span class="na"&gt;startsecs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;10&lt;/span&gt;
&lt;span class="na"&gt;stdout_logfile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/tmp/service2.log&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Сервисы:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@development:/opt/bin# cat service1
&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Start: $(date -R)&amp;quot;&lt;/span&gt;

&lt;span class="nb"&gt;exec &lt;/span&gt;dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/zero &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/null &lt;span class="nv"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1M
root@development:/opt/bin# cat service2
&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Start: $(date -R)&amp;quot;&lt;/span&gt;

&lt;span class="nb"&gt;exec &lt;/span&gt;dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/zero &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/null &lt;span class="nv"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;2M
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Самое логичное, что можно предположить - сервисы будут запускаться в следующем порядке:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Запуск service1;&lt;/li&gt;
&lt;li&gt;Ждем 10 секунд. Сервис работает. Считаем, что он запущен успешно;&lt;/li&gt;
&lt;li&gt;Запуск service2;&lt;/li&gt;
&lt;li&gt;Ждем 10 секунд. Сервис работает. Считаем, что он запущен успешно;&lt;/li&gt;
&lt;li&gt;Profit.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Что получаем на самом деле:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# tail -f /var/log/supervisor/supervisord.log
00:33:17,868 INFO spawned: &amp;#39;service1&amp;#39; with pid 6532
00:33:17,897 INFO spawned: &amp;#39;service2&amp;#39; with pid 6533
00:33:27,997 INFO success: service1 entered RUNNING state, process
 has stayed up for &amp;gt; than 10 seconds (startsecs)
00:33:27,997 INFO success: service2 entered RUNNING state, process
 has stayed up for &amp;gt; than 10 seconds (startsecs)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="web-interface"&gt;
&lt;h2&gt;Web-interface&lt;/h2&gt;
&lt;p&gt;Web интерфейс доступен &amp;quot;из коробки&amp;quot;. Позволяет:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Cмотреть статус сервисов;&lt;/li&gt;
&lt;li&gt;Смотреть лог сервиса;&lt;/li&gt;
&lt;li&gt;Очистить лог сервиса;&lt;/li&gt;
&lt;li&gt;Остановить/запустить сервис.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="events"&gt;
&lt;h2&gt;Events&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://supervisord.org/events.html"&gt;Документация на сайте проекта&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Event'ы еще одна значимая часть supervisord - позволяет реагировать на возникающие события (изменения статуса сервиса, новое сообщение в STDOUT/STDERR в логе сервиса и др. Полный список доступных событий - &lt;a class="reference external" href="http://supervisord.org/events.html#event-types"&gt;тут&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Примеры применения:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Послать письмо, если сервис упал;&lt;/li&gt;
&lt;li&gt;Послать изменение состояния в систему мониторинга;&lt;/li&gt;
&lt;li&gt;Перезапустить связанный сервис на этом или др. сервере (через XML-RPC).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Что бы начать реагировать на события необходимо настроить свой event-listener. Event-listener будет запущен supervisord как
дочерний процесс, а информация о событиях будет передаваться ему на STDIN, а через STDOUT он должен оповещать supervisord
о своем текущем статусе.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Пример настройки event-listener'а:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# cat /etc/supervisor/conf.d/listener.conf&lt;/span&gt;
&lt;span class="k"&gt;[eventlistener:watcher]&lt;/span&gt;
&lt;span class="na"&gt;command&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/opt/bin/watcher.py&lt;/span&gt;
&lt;span class="na"&gt;events&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;PROCESS_STATE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Пример event-listener'а:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;w&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flush&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;e&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flush&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;READY&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readline&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# debug&lt;/span&gt;
        &lt;span class="c"&gt;# parse line and do something&lt;/span&gt;
        &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;RESULT 2&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;OK&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;В STDERR event-listener'а при перезапуске service1 будет писаться следующее:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;processname:service1 groupname:service1 from_state:RUNNING pid:9915ver:3.0
server:supervisor01 serial:47 pool:watcher poolserial:7
eventname:PROCESS_STATE_STOPPED len:68
processname:service1 groupname:service1 from_state:STOPPING pid:9915ver:3.0
server:supervisor01 serial:48 pool:watcher poolserial:8
eventname:PROCESS_STATE_STARTING len:66
processname:service1 groupname:service1 from_state:STOPPED tries:0ver:3.0
server:supervisor01 serial:49 pool:watcher poolserial:9
eventname:PROCESS_STATE_RUNNING len:68
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h2&gt;Выводы&lt;/h2&gt;
&lt;p&gt;Вцелом supervisord выглядит как вменяемый законченный продукт (надо будет заняться исправлением поведения с порядком запуска
сервисов). Если сравнивать его со связкой &lt;a class="reference external" href="http://smarden.org/runit/"&gt;runit&lt;/a&gt; + &lt;a class="reference external" href="https://github.com/Undev/runit-man"&gt;runit-man&lt;/a&gt; он больше похож на то, что можно использовать в production
окружении. Но.. но основные достоинства supervisord просто бесполезны в случае использования chef:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Управление сервисами на удаленном сервере (через XML-RPC или supervisorctl -s SERVER_NAME). Вам это не надо, ведь у вас есть knife с поиском по ролям, нодам и тегам;&lt;/li&gt;
&lt;li&gt;Запуск нескольких инстансов демона без объявления нескольких сервисов. Опять же не особо полезно, ведь за вас эти сервисы настраивает chef. И сколько их 1, 10 или 100 вцелом не так уж и важно.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ссылки по теме:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://python.mirocommunity.org/video/1798/pyohio-2010-controlling-unix-p"&gt;Выступление Calvin Hendryx-Parker&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">HISTTIMEFORMAT</title>
    <id>http://verm666.github.com/2011/10/03/bash_history</id>
    <updated>2011-10-03T00:00:00Z</updated>
    <link href="http://verm666.github.com/2011/10/03/bash_history" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;Q: Как в history вывести время выполнения команды?&lt;/li&gt;
&lt;li&gt;A: Выставить значение переменной HISTTIMEFORMAT (в формате &lt;a class="reference external" href="http://www.manpagez.com/man/3/strftime/"&gt;strftime&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# export HISTTIMEFORMAT=&amp;quot;+%Y/%m/%d - %H:%M:%S % &amp;quot;
# history 3
    44  2011/10/03 - 16:27:55 % ls
    45  2011/10/03 - 16:27:59 % export HISTTIMEFORMAT=&amp;quot;%Y/%m/%d - %H:%M:%S % &amp;quot;
    46  2011/10/03 - 16:28:01 % history 3
&lt;/pre&gt;&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">Python Bookmarks</title>
    <id>http://verm666.github.com/2011/09/20/python_bookmarks</id>
    <updated>2011-09-20T00:00:00Z</updated>
    <link href="http://verm666.github.com/2011/09/20/python_bookmarks" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;div class="section" id="books"&gt;
&lt;h2&gt;Books&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;David M. Beazley - Python Essential Reference, 4th Edition&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="gil"&gt;
&lt;h2&gt;GIL&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;David M. Beazley - PyCon 2010:Understanding the Python GIL (#82) - &lt;a class="reference external" href="http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2010-understanding-the-python-gil-82-3273690"&gt;http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2010-understanding-the-python-gil-82-3273690&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">Memory as a programming concept in C and C++</title>
    <id>http://verm666.github.com/2011/09/09/memory_as_a_programming_concept</id>
    <updated>2011-09-09T00:00:00Z</updated>
    <link href="http://verm666.github.com/2011/09/09/memory_as_a_programming_concept" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;Название книги: Memory as a Programming Concept in C and C++&lt;/li&gt;
&lt;li&gt;Автор: Frantisek Franek&lt;/li&gt;
&lt;li&gt;Amazon: &lt;a class="reference external" href="http://www.amazon.com/Memory-Programming-Concept-Frantisek-Franek/dp/0521520436"&gt;http://www.amazon.com/Memory-Programming-Concept-Frantisek-Franek/dp/0521520436&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>

