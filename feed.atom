<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Recent Blog Posts</title>
  <id>http://verm666.github.com/feed.atom</id>
  <updated>2012-12-27T00:00:00Z</updated>
  <link href="http://verm666.github.com/" />
  <link href="http://verm666.github.com/feed.atom" rel="self" />
  <subtitle type="text">Recent blog posts</subtitle>
  <generator>Werkzeug</generator>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">ElasticSearch. Часть 1</title>
    <id>http://verm666.github.com/2012/12/27/elasticsearch_1</id>
    <updated>2012-12-27T00:00:00Z</updated>
    <link href="http://verm666.github.com/2012/12/27/elasticsearch_1" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;Полезные ссылки&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;офф. сайт OpenSource проекта: &lt;a class="reference external" href="http://www.elasticsearch.org"&gt;http://www.elasticsearch.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;github: &lt;a class="reference external" href="https://github.com/elasticsearch"&gt;https://github.com/elasticsearch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;Версионирование&lt;/h2&gt;
&lt;p&gt;Первое с чем нужно определиться перед установкой - это зачем вам нужен
ElasticSearch. В зависимости от целей придется брать разные версии.&lt;/p&gt;
&lt;p&gt;Например: если вы хотите в качестве источника данных использовать CouchDB -
вам нужно будет поставить river, последняя версия которого совместима с релизом
ElasticSearch 0.18.7. Если вы будете сами наполнять ElasticSearch данными (
например через HTTP интерфейс) - то можно взять последний стабильный - 0.20.1.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;Установка&lt;/h2&gt;
&lt;p&gt;Я не смотрел на мир Java порядка 4-х лет. И либо все стало совсем хорошо, либо
ребята из ElasticSearch постарались. Ставится поисковый движок за 2 минуты.&lt;/p&gt;
&lt;p&gt;Разумеется для работы нужен jdk. Моя текущая инсталляция работает на:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% java -version
java version &lt;span class="s2"&gt;&amp;quot;1.6.0_24&amp;quot;&lt;/span&gt;
OpenJDK Runtime Environment &lt;span class="o"&gt;(&lt;/span&gt;IcedTea6 1.11.5&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;rhel-1.50.1.11.5.el6_3-x86_64&lt;span class="o"&gt;)&lt;/span&gt;
OpenJDK 64-Bit Server VM &lt;span class="o"&gt;(&lt;/span&gt;build 20.0-b12, mixed mode&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Я приведу пример установки версии 0.18.7 (да, ниже будет показана работа с
CouchDB).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% &lt;span class="nb"&gt;cd&lt;/span&gt; /opt
% wget http://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-0.18.7.tar.gz
% tar zxfv elasticsearch-0.18.7.tar.gz
% ln -s elasticsearch-0.18.7 elasticsearch
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Запуск в foreground:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% &lt;span class="nb"&gt;cd &lt;/span&gt;elasticsearch
% ./bin/elasticsearch -f
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="couchdb-river"&gt;
&lt;h2&gt;CouchDB-river&lt;/h2&gt;
&lt;p&gt;River - это встраиваемая сущность в ElasticSearch, которая занимается
наполнением поискового движка данными.&lt;/p&gt;
&lt;p&gt;Установка river-а осуществляется через команду &lt;em&gt;plugin&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% ./bin/plugin -install river-couchdb
-&amp;gt; Installing river-couchdb...
Trying http://elasticsearch.googlecode.com/svn/plugins/river-couchdb/elasticsearch-river-couchdb-0.18.7.zip...
Downloading .........DONE
Installed river-couchdb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Тоже самое можно сделать и самостоятельно. В результате у вас должно быть
следующее:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% &lt;span class="nb"&gt;cd&lt;/span&gt; /opt/elasticsearch
% find ./plugins
./plugins
./plugins/river-couchdb
./plugins/river-couchdb/elasticsearch-river-couchdb-0.18.7.jar
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;В случае CouchDB river подключается на &lt;a class="reference external" href="http://wiki.apache.org/couchdb/HTTP_database_API#Changes"&gt;_changes&lt;/a&gt;
для указанной нами базы и, получая свежие изменения добавляет их в поисковый
движок.&lt;/p&gt;
&lt;p&gt;Настройка river выглядит следующим образом:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% curl -XPUT &lt;span class="s1"&gt;&amp;#39;http://127.0.0.1:9200/_river/verm666/_meta&amp;#39;&lt;/span&gt; -d &lt;span class="s1"&gt;&amp;#39;{&lt;/span&gt;
&lt;span class="s1"&gt;  &amp;quot;type&amp;quot; : &amp;quot;couchdb&amp;quot;,&lt;/span&gt;
&lt;span class="s1"&gt;  &amp;quot;couchdb&amp;quot; : {&lt;/span&gt;
&lt;span class="s1"&gt;      &amp;quot;host&amp;quot; : &amp;quot;127.0.0.1&amp;quot;,&lt;/span&gt;
&lt;span class="s1"&gt;      &amp;quot;port&amp;quot; : 5984,&lt;/span&gt;
&lt;span class="s1"&gt;      &amp;quot;db&amp;quot; : &amp;quot;verm666&amp;quot;,&lt;/span&gt;
&lt;span class="s1"&gt;      &amp;quot;filter&amp;quot; : null&lt;/span&gt;
&lt;span class="s1"&gt;  },&lt;/span&gt;
&lt;span class="s1"&gt;  &amp;quot;index&amp;quot; : {&lt;/span&gt;
&lt;span class="s1"&gt;      &amp;quot;index&amp;quot; : &amp;quot;verm666&amp;quot;,&lt;/span&gt;
&lt;span class="s1"&gt;      &amp;quot;type&amp;quot; : &amp;quot;verm666&amp;quot;,&lt;/span&gt;
&lt;span class="s1"&gt;      &amp;quot;bulk_size&amp;quot; : &amp;quot;100&amp;quot;,&lt;/span&gt;
&lt;span class="s1"&gt;      &amp;quot;bulk_timeout&amp;quot; : &amp;quot;10ms&amp;quot;&lt;/span&gt;
&lt;span class="s1"&gt;  }&lt;/span&gt;
&lt;span class="s1"&gt;}&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;После этого в логах CouchDB должна появиться запись вида:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% &lt;span class="o"&gt;[&lt;/span&gt;Thu, 27 Dec 2012 06:18:16 GMT&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;info&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;0.338.0&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; 127.0.0.1 - - &lt;span class="s1"&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;
/verm666/_changes?feed&lt;span class="o"&gt;=&lt;/span&gt;continuous&amp;amp;include_docs&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&amp;amp;heartbeat&lt;span class="o"&gt;=&lt;/span&gt;10000&amp;amp;since&lt;span class="o"&gt;=&lt;/span&gt;5 200
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;И по полям документов из CouchDB можно будет искать:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% curl -XGET &lt;span class="s1"&gt;&amp;#39;http://localhost:9200/verm666/_search?q=name:Billy&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;_shards&amp;quot;&lt;/span&gt;: &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="s2"&gt;&amp;quot;failed&amp;quot;&lt;/span&gt;: 0,
        &lt;span class="s2"&gt;&amp;quot;successful&amp;quot;&lt;/span&gt;: 5,
        &lt;span class="s2"&gt;&amp;quot;total&amp;quot;&lt;/span&gt;: 5
    &lt;span class="o"&gt;}&lt;/span&gt;,
    &lt;span class="s2"&gt;&amp;quot;hits&amp;quot;&lt;/span&gt;: &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="s2"&gt;&amp;quot;hits&amp;quot;&lt;/span&gt;: &lt;span class="o"&gt;[&lt;/span&gt;
          &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="s2"&gt;&amp;quot;_id&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;b6cbe74d06265494d7b4bba297000068&amp;quot;&lt;/span&gt;,
            &lt;span class="s2"&gt;&amp;quot;_index&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;verm666&amp;quot;&lt;/span&gt;,
            &lt;span class="s2"&gt;&amp;quot;_score&amp;quot;&lt;/span&gt;: 1.0,
            &lt;span class="s2"&gt;&amp;quot;_source&amp;quot;&lt;/span&gt;: &lt;span class="o"&gt;{&lt;/span&gt;
              &lt;span class="s2"&gt;&amp;quot;_id&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;b6cbe74d06265494d7b4bba297000068&amp;quot;&lt;/span&gt;,
              &lt;span class="s2"&gt;&amp;quot;_rev&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;1-9349fbd38a04e647772c7c7be8b11d7a&amp;quot;&lt;/span&gt;,
              &lt;span class="s2"&gt;&amp;quot;byname&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;Wings&amp;quot;&lt;/span&gt;,
              &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;Billy&amp;quot;&lt;/span&gt;,
              &lt;span class="s2"&gt;&amp;quot;quote&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;Pill popping, cunt eating, dope smoking, mother fucker.&amp;quot;&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;,
            &lt;span class="s2"&gt;&amp;quot;_type&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;verm666&amp;quot;&lt;/span&gt;
          &lt;span class="o"&gt;}&lt;/span&gt;
      &lt;span class="o"&gt;]&lt;/span&gt;,
      &lt;span class="s2"&gt;&amp;quot;max_score&amp;quot;&lt;/span&gt;: 1.0,
      &lt;span class="s2"&gt;&amp;quot;total&amp;quot;&lt;/span&gt;: 1
    &lt;span class="o"&gt;}&lt;/span&gt;,
    &lt;span class="s2"&gt;&amp;quot;timed_out&amp;quot;&lt;/span&gt;: &lt;span class="nb"&gt;false&lt;/span&gt;,
    &lt;span class="s2"&gt;&amp;quot;took&amp;quot;&lt;/span&gt;: 2
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;Выводы&lt;/h2&gt;
&lt;p&gt;Никаких выводов по итогам данной статьи я делать не буду. Про настройку
кластера, репликаций и шарднинга я напишу в след. части.&lt;/p&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">Nginx. Что нового?</title>
    <id>http://verm666.github.com/2012/03/20/nginx_news</id>
    <updated>2012-03-20T00:00:00Z</updated>
    <link href="http://verm666.github.com/2012/03/20/nginx_news" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;div class="section" id="nginx"&gt;
&lt;h2&gt;Nginx. Что нового?&lt;/h2&gt;
&lt;div class="section" id="disable-symlinks"&gt;
&lt;h3&gt;disable_symlinks&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;модуль: ngx_http_core_module&lt;/li&gt;
&lt;li&gt;офф. описание: &lt;a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_core_module.html#disable_symlinks"&gt;ngx_http_core_module.html#disable_symlinks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Директива определяет как вести себя с символическими ссылками при открытии
файла. Офф. описания более чем достаточно, что бы понять как этим пользоваться.&lt;/p&gt;
&lt;p&gt;Если честно, сейчас я не вижу какого-то реального применения этой директивы,
особенно с учетом того, что в модуле ngx_http_autoindex_module эта директива
игнорируется, а ведь именно там порой и хочется странного. Ждем.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="proxy-cookie-domain"&gt;
&lt;h3&gt;proxy_cookie_domain&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;модуль: ngx_http_proxy_module&lt;/li&gt;
&lt;li&gt;офф. описание: &lt;a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_proxy_module.html#proxy_cookie_domain"&gt;ngx_http_proxy_module.html#proxy_cookie_domain&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Директива позволяет подменять domain в Cookie в ответе от бэкенда. По сути
такой аналог proxy_redirect только для Cookie.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="so-keepalive"&gt;
&lt;h3&gt;so_keepalive&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;модуль: ngx_http_core_module&lt;/li&gt;
&lt;li&gt;офф. описание: &lt;a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_core_module.html#listen"&gt;ngx_http_core_module.html#listen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Возможность переопределить след. пареметры из sysctl:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;tcp_keepalive_time&lt;/li&gt;
&lt;li&gt;tcp_keepalive_intvl&lt;/li&gt;
&lt;li&gt;tcp_keepalive_probes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;и вкл/выкл SO_KEEPALIVE на сокете.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="https-if-not-empty"&gt;
&lt;h3&gt;$https и if_not_empty&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;модуль: ngx_http_core_module&lt;/li&gt;
&lt;li&gt;офф. описание: &lt;a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_core_module.html#variables"&gt;ngx_http_core_module.html#variables&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Используется в fastcgi/uwsgi/etc_params совместно с новой директивой
if_not_empty, так как в случае http соединения - значением переменной
будет пустая строка. Польза от новой переменной очевидная и банальная -
простой и удобный интерфейс для выставления еще одной переменной (HTTPS)
в параметрах запроса к бэкенду. Раньше наверное это можно было нагородить
из if и переменной $scheme.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="proxy-redirect"&gt;
&lt;h3&gt;proxy_redirect с переменными и регулярными выражениями&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;модуль: ngx_http_proxy_module&lt;/li&gt;
&lt;li&gt;офф. описание: &lt;a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_proxy_module.html#proxy_redirect"&gt;ngx_http_proxy_module.html#proxy_redirect&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Теперь в первом аргументе proxy_redirect можно использовать переменные и
регулярные выражения (причем с capture groups). Теперь можно строить еще более
извращенные динамические правила. Неописуемый восторг.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="keepalive-upstream"&gt;
&lt;h3&gt;keepalive в соединении к upstream&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;модуль: ngx_http_upstream_module&lt;/li&gt;
&lt;li&gt;офф. описание: &lt;a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_upstream_module.html#keepalive"&gt;ngx_http_upstream_module.html#keepalive&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Работает это так:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Создаем upstream с keepalive 10;&lt;/li&gt;
&lt;li&gt;Делаем первый запрос, который уходит на этот upstream;&lt;/li&gt;
&lt;li&gt;После выполнения запроса TCP соединение остается жить (state: ESTABLISHED);&lt;/li&gt;
&lt;li&gt;Делаем 100 параллельных подключений. В это время к upstream будет установлено
100 соединений. После выполнения всех 100 запросов - 10 останется в ESTABLISED
состоянии. Лишние соединения закрываются.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Чуть подробнее об особенностях этих соединений:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Кол-во персистентных соединений указывается для всех серверов в группе. Т.е.
если у вас три сервера в группе и значение keepalive равно 30, то эти 30
соединений будут распределены между тремя серверами в группе.&lt;/li&gt;
&lt;li&gt;Соединения распределяются неравномерно по серверам в группе. Сколько
соединений устанавливается к каждому серверу группы зависит напрямую от того
на какой из группы приходили последние соединения, т.к. заркываются наиболее
старые лишние соединения независимо от того, на один сервер из группы они
пришли или на разные. Это очень хорошо видно, если один сервер из группы
отвечает на запросы быстрее остальных. К такому серверу будет меньше (или
вообще не будет) соединений.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Польза от данной директивы очевидная: мы не теряем время на TCP handshake.
Разница должна хорошо ощущаться при переносе проекта на др. хостинг с proxy_pass
на старом.&lt;/p&gt;
&lt;p&gt;Для fastcgi есть аналогичная директива - &lt;a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_fastcgi_module.html#fastcgi_keep_conn"&gt;fastcgi_keep_conn&lt;/a&gt;
.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="proxy-cache-lock"&gt;
&lt;h3&gt;proxy_cache_lock&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;модуль: ngx_http_proxy_module&lt;/li&gt;
&lt;li&gt;офф. описание: &lt;a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_proxy_module.html#proxy_cache_lock"&gt;ngx_http_proxy_module.html#proxy_cache_lock&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Об этой директиве я уже вскользь упоминал в &lt;a class="reference external" href="http://verm666.name/2012/03/17/xxx_farm/"&gt;предыдущем посте&lt;/a&gt;. Позволяет удерживать одновременные
запросы к бэкенду и отдавать всем клиентам ответ полученный от первого запроса.&lt;/p&gt;
&lt;p&gt;Приемущества:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Если обработка запросом бэкенда является дорогой (долгой) операцией, то
использование данной директивы очень упростит вам жизнь. Простой пример
- HTTP Live Streaming, когда бэкенд генерирует плейлисты и видео файлы для
этих плейлистов.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Минусы:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;В случае проблем с ушедшим на бэкенд запросом (потеряный SYN, ретрансмит
пакета), ответ от которого ждут все клиенты - появится дополнительная
задержка для каждого клиента.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;Выводы&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Nginx 0.7 и текущая версия - это 2 довольно различных продукта;&lt;/li&gt;
&lt;li&gt;Настоятельно рекомендую читать то, что пишется в CHANGES;&lt;/li&gt;
&lt;li&gt;Если вы считаете, что последняя ветка нестабильна - вы неправы.
Сайт проекта webvybory2012.ru работал на 1.1.14 с минимальными изменениями.
Полет был нормальный;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="p-s"&gt;
&lt;h2&gt;P.S.&lt;/h2&gt;
&lt;p&gt;Почему мало кто знает про &lt;a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors"&gt;proxy_intercept_errors&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">Ферма для XXX с хранилищем за день</title>
    <id>http://verm666.github.com/2012/03/17/xxx_farm</id>
    <updated>2012-03-17T00:00:00Z</updated>
    <link href="http://verm666.github.com/2012/03/17/xxx_farm" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;Описание задачи&lt;/h2&gt;
&lt;p&gt;Предоставить сервис, который должен:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Принять запрос от клиента на получение видео файла;&lt;/li&gt;
&lt;li&gt;Получить видео данные в контейнере А от др. сервиса (назовем его L);&lt;/li&gt;
&lt;li&gt;Перепаковать в контейнер B;&lt;/li&gt;
&lt;li&gt;Сохранить полученный файл;&lt;/li&gt;
&lt;li&gt;Отдать полученный файл клиенту;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;При этом:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;При последующих запросах файла - он должен отдаваться без обращения к бэкенду;&lt;/li&gt;
&lt;li&gt;Если на сервис приходит одновременно несколько запросов за одним файлом -
на бэкенд должен уходить только первый, остальные ждут и получают результат первого.&lt;/li&gt;
&lt;li&gt;Должна быть предоставлена возможность перегенерации полученного файла;&lt;/li&gt;
&lt;li&gt;Ссылка на файл должна иметь время ограниченное жизни.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;Размах проблемы&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&amp;gt; 20 000 запросов на изготовление файлов. Каждый размером ~ 100 МБ;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;Оборудование, которое было под руками&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Сервер (далее S) с 32-мя 3ТБ дисками и 3ware RAID контроллером (9xxx серия);&lt;/li&gt;
&lt;li&gt;N серверов с памятью и процессорами (назовем их W) - будут заниматься обработкой видео.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;Полученное решение&lt;/h2&gt;
&lt;div class="section" id="m"&gt;
&lt;h3&gt;Число M&lt;/h3&gt;
&lt;p&gt;Число M - максимальное число W-серверов в ферме. Выбирается один раз и навсегда.
Изменить его потом будет очень сложно. По сути является ограничением
масштабирования нашей фермы. Я взял 64. Красивое число да и W-серверов больше нет.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;Хранилище&lt;/h3&gt;
&lt;p&gt;Первое о чем приходится задуматься - предоставление доступа к S-серверу с
любого W-сервера. При этом хочется иметь POSIX-совместимый доступ к файлам.&lt;/p&gt;
&lt;p&gt;Как ни странно связка XFS + NFS будет работать весьма неплохо. Да, в RW доступе.
Да, сразу на всех W-серверах. Нет, я не ебанулся.&lt;/p&gt;
&lt;p&gt;На самом деле сказанное выше (а именно RW доступ на всех W-серверах) не совсем
верно. Доступ будет, но мы не будем им пользоваться.&lt;/p&gt;
&lt;p&gt;В итоге:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Из всех дисков создаем RAID-6. Получаем 82 ТБ дискового пространства;&lt;/li&gt;
&lt;li&gt;Создаем на базе этого блочного устройства LVM VG;&lt;/li&gt;
&lt;li&gt;Нарезаем на M (смотри выше) LV;&lt;/li&gt;
&lt;li&gt;Создаем на них XFS;&lt;/li&gt;
&lt;li&gt;Монтируем в /storage/video/[1..M];&lt;/li&gt;
&lt;li&gt;Раздаем через NFS всем W-серверам в rw доступе.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;На этом настройка хранилища заканчивается. Больше о нем думать не надо.
Теперь надо просто добиться того, что бы в каждую отдельно взятую
точку монтирования отданную через NFS писал только 1 W-сервер. Этим
будет заниматься Балансер (Nginx).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h3&gt;Балансер&lt;/h3&gt;
&lt;p&gt;Для балансировки запросов к W-серверам и хранилищу будет использоваться Nginx.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;version &amp;gt;= 1.1.13 (из-за cache_lock);&lt;/li&gt;
&lt;li&gt;add ngx_secure_download;&lt;/li&gt;
&lt;li&gt;add ngx_mod_perl.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;На балансере точно так же как и на W-серверах монтируются все Logical Volume-ы
c S-сервера, только в ro режиме, так как писать нам на балансере не надо.&lt;/p&gt;
&lt;p&gt;Сразу приведу итоговый конф. файл, что бы было поянтно о чем я говорю:
&lt;a class="reference external" href="/static/my/xxx_farm_nginx.conf"&gt;nginx.conf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;На nginx приходят запросы вида: /video/uuid/begin-end.mp4/md5sum/hex_ts, где&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;uuid - некий ID, является идентификатором для обращения к сервису L;&lt;/li&gt;
&lt;li&gt;begin - timestamp начала получаемого файла;&lt;/li&gt;
&lt;li&gt;end - timestamp конца получаемого файла;&lt;/li&gt;
&lt;li&gt;md5sum/hex_ts - кусочки от ngx_secure_download.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;И так, пойдем по порядку:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Ограничение времени жизни ссылки на скачивание достигается через
ngx_secure_download;&lt;/li&gt;
&lt;li&gt;Балансировку между W-серверами и Logical Volume-ами S-сервера будет за нас
делать mod_perl, &lt;a class="reference external" href="http://www.cse.yorku.ca/~oz/hash.html"&gt;djb2&lt;/a&gt; и число M.
Таким образом запрос по конкретному uuid всегда будет уходить
на один и тот же W-сервер (см. map $shard $backend).
Итоговый файл для этого uuid всегда будет записываться в один и тот же
Logical Volume на S-сервере и запись в него будет производить только
один W-сервер.&lt;/li&gt;
&lt;li&gt;Удерживать одинаковые запросы к бэкенду будет cache_lock (если бы эта директива
не появилась в последних релизах - пришлось бы добавить еще Varnish. Так как до
недавнего времени именно этот кэш-сервер умел это делать);&lt;/li&gt;
&lt;li&gt;Возможность пересоздать файл предоставляется через отдельный server на др. порту
(можно было сделать просто отдельный location, но 80-й порт открыт в Internet);&lt;/li&gt;
&lt;li&gt;Отдача ранее сгенерированных файлов - try_files.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;Бэкенд&lt;/h3&gt;
&lt;p&gt;Собстенно это небольшой python (flask + eventlet) сервис, который делает несколько
простых операций:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Забирает файл с сервиса L;&lt;/li&gt;
&lt;li&gt;Перепаковывает в конейнер B;&lt;/li&gt;
&lt;li&gt;Записывает файл в нужный Logical Volume;&lt;/li&gt;
&lt;li&gt;Через X-Accel-Redirect отдает файл в Nginx (см. location /internal_video).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Кстати, ленивые для подобных (или любых других операций) могут воспользоваться
&lt;a class="reference external" href="https://github.com/verm666/joyer"&gt;Joyer&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3&gt;Еще пара слов про масшабирование&lt;/h3&gt;
&lt;p&gt;Добавление нового W-сервера приводит к тому, что мы добавляем его в
map $shard $backend. Равномерно распределяя shard-ы по бэкендам.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h2&gt;Выводы&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Если у вас есть возможность что-то вынести в mod_perl в Nginx - это
стоит сделать (сходить в memcache, посмотреть в cookie или как в этом случае -
получить возможность однозначной балансировки от некоторой переменной);&lt;/li&gt;
&lt;li&gt;Если включать мозг - наличие NFS в проекте не всегда плохо.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h2&gt;Литература по теме&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Nginx Secure Download - &lt;a class="reference external" href="http://wiki.nginx.org/HttpSecureDownload"&gt;http://wiki.nginx.org/HttpSecureDownload&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Message Authentication Code - &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Message_authentication_code"&gt;http://en.wikipedia.org/wiki/Message_authentication_code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;djb2 - &lt;a class="reference external" href="http://www.cse.yorku.ca/~oz/hash.html"&gt;http://www.cse.yorku.ca/~oz/hash.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Nginx cache_lock - &lt;a class="reference external" href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_lock"&gt;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_lock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;nginx.conf - &lt;a class="reference external" href="http://verm666.name/static/my/xxx_farm_nginx.conf"&gt;http://verm666.name/static/my/xxx_farm_nginx.conf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;joyer - &lt;a class="reference external" href="https://github.com/verm666/joyer"&gt;https://github.com/verm666/joyer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="p-s"&gt;
&lt;h2&gt;P.S.&lt;/h2&gt;
&lt;p&gt;XXX - это не значит, что решение используется в сфере связанной с порнографией ;).&lt;/p&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">Приватный репозиторий OBS</title>
    <id>http://verm666.github.com/2012/01/15/stand_alone_OBS</id>
    <updated>2012-01-15T00:00:00Z</updated>
    <link href="http://verm666.github.com/2012/01/15/stand_alone_OBS" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;Вступление&lt;/h2&gt;
&lt;p&gt;После того, как в субботу вечером в очередной раз build.opensuse.org лег и начал
отдавать на все запросы 503 терпение закончилось и было решено отвязаться
от внешнего сервиса окончательно.&lt;/p&gt;
&lt;p&gt;В wiki проекта можно найти несколько упоминаний о том, как это можно сделать. Но
на примере rpm-based дистрибутивов. И ни одного примера для Debian. Ниже будет
описано как это сделать для Debian 6.0 (x86_64).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="forever-alone"&gt;
&lt;h2&gt;Forever alone&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Создаем новый проект в OBS (Debian);&lt;/li&gt;
&lt;li&gt;Создаем в нем подпроект (6:0);&lt;/li&gt;
&lt;li&gt;Вносим изменения в Raw config проекта (Project-&amp;gt;Advanced-&amp;gt;Raw Config);&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;project&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Debian:6.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;6.0&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;description/&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;person&lt;/span&gt; &lt;span class="na"&gt;role=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;maintainer&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;userid=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;verm666&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;person&lt;/span&gt; &lt;span class="na"&gt;role=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bugowner&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;userid=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;verm666&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;repository&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;standard&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;arch&amp;gt;&lt;/span&gt;x86_64&lt;span class="nt"&gt;&amp;lt;/arch&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Заливаем projconf (Projct-&amp;gt;Advanced-&amp;gt;Project Config);&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Именно из-за этого пункта я пишу эту заметку. Т.к. готового конфига в rpm
пакетах OBS нет (если для Lenny, но он немного не работает),
а при лежащем build.opensuse.org искать его, по факту, негде.&lt;/p&gt;
&lt;p&gt;Мой projconf для Debian_6.0 можно взять &lt;a class="reference external" href="/static/my/Debian_6.0_prjconf.txt"&gt;тут&lt;/a&gt;.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Заходим на сервер по ssh и создаем директорию для бинарных пакетов нашего проекта:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# mkdir -p /srv/obs/build/Debian\:6.0/standard/x86_64/\:full/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Кладем в эту директорию все пакеты для Debian Squeeze x86_64
(я использовал debmirror);&lt;/p&gt;
&lt;p&gt;Индексируем проект:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# /usr/lib/obs/server/bs_admin --rescan-repository Debian:6.0 standard x86_64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Смотрим логи obsscheduler'а:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# tail -f /srv/obs/log/scheduler_x86_64.log
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;Сборка пакетов&lt;/h2&gt;
&lt;p&gt;Для сборки своих пакетов создается отдельный репозиторий и подключается как
build target через advanced interface (Or pick one via advanced interface. На
странице с репозиториями проекта)&lt;/p&gt;
&lt;p&gt;Hint: В 'New name' лучше указывать Debian_6.0 (такое же название, какое
используется при работе с внешним OBS. Таким образом после отключения внешнего
OBS ссылки на репозиторий с deb пакетами останутся прежними и вам не придется
вносить изменения в sources.list)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;Ссылки по теме&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://en.opensuse.org/openSUSE:Build_Service_prjconf"&gt;http://en.opensuse.org/openSUSE:Build_Service_prjconf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://en.opensuse.org/openSUSE:Build_Service_adding_build_targets"&gt;http://en.opensuse.org/openSUSE:Build_Service_adding_build_targets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://en.opensuse.org/openSUSE:Build_Service_private_instance_boot_strapping"&gt;http://en.opensuse.org/openSUSE:Build_Service_private_instance_boot_strapping&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">Shebang</title>
    <id>http://verm666.github.com/2011/12/15/shebang</id>
    <updated>2011-12-15T00:00:00Z</updated>
    <link href="http://verm666.github.com/2011/12/15/shebang" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;p&gt;В комлекте с ixgbe-3.9.2 идет небольшой скрипт, раскидывающий прерывания по
ядрам, но речь сейчас не о affinity.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;% head -2 scripts/set_irq_affinity.sh
# setting up irq affinity according to /proc/interrupts
# 2008-11-25 Robert Olsson
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Вот так выглядят первые две строчки скрипта. Запускаем руками в консоли -
все хорошо. Без задней мысли дописываем в /etc/network/interfaces&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;...
up /etc/network/set_irq_affinity.sh eth0
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;и теряем сервер.&lt;/p&gt;
&lt;p&gt;Причина банальна - скрипт запускается в sh, который в debian squeeze является
символической ссылкой на dash. На 32 строке скрипта:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;...
for ((i=1; i&amp;lt;=$IDX;i++)))
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;скрипт завершается с ошибкой &lt;strong&gt;Syntax error: Bad for loop variable&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;Выводы&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Товарищи из Intel могли бы и подумать;&lt;/li&gt;
&lt;li&gt;Никому нельзя верить и все надо проверять.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="p-s"&gt;
&lt;h2&gt;p.s.&lt;/h2&gt;
&lt;p&gt;Да, сервер еще не был в production и паника немного не уместна, но печально.&lt;/p&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">Goblr</title>
    <id>http://verm666.github.com/2011/10/13/goblr</id>
    <updated>2011-10-13T00:00:00Z</updated>
    <link href="http://verm666.github.com/2011/10/13/goblr" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;p&gt;Goblr (&lt;strong&gt;G&lt;/strong&gt;ithub/&lt;strong&gt;G&lt;/strong&gt;itorious to &lt;strong&gt;OB&lt;/strong&gt;S &lt;strong&gt;L&lt;/strong&gt;ightweight &lt;strong&gt;R&lt;/strong&gt;outer) - небольшой сервис
занимающийся интеграцией git хостингов и openSUSE Build Service.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Домашная страница проекта: &lt;a class="reference external" href="https://github.com/verm666/goblr"&gt;https://github.com/verm666/goblr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wiki проекта: &lt;a class="reference external" href="https://github.com/verm666/goblr/wiki"&gt;https://github.com/verm666/goblr/wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Публичная инсталляция: &lt;a class="reference external" href="http://goblr.verm666.name"&gt;http://goblr.verm666.name&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">Supervisord</title>
    <id>http://verm666.github.com/2011/10/07/supervisord</id>
    <updated>2011-10-07T00:00:00Z</updated>
    <link href="http://verm666.github.com/2011/10/07/supervisord" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;Введение&lt;/h2&gt;
&lt;p&gt;Supervisord - еще один из (кроме runit, launchd, systemd, upstart и т.п.) продуктов
занимающихся слежением за сервисами, запущенными в виде дочерних процессов.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://supervisord.org"&gt;Официальный сайт&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/supervisor/supervisor"&gt;Guthub репозиторий&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Написан на Python. Для всех операций по управлению сервисами (start/stop/etc) как в web-interface, так
и в supervisorctl использует XML-RPC.&lt;/p&gt;
&lt;p&gt;О том как поставить и запустить сам supervisord можно прочитать на &lt;a class="reference external" href="http://supervisord.org"&gt;сайте проекта&lt;/a&gt;.
Ниже я опишу только те моменты, которые мне показались интересными.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;Добавление нового сервиса&lt;/h2&gt;
&lt;p&gt;Добавление нового сервиса осуществляется через редактирование основного конф. файла (supervisord.conf)
или созданием отдельного конф. файла, который будет подключен через директиву include.
Простой пример конфигурационного файла для демона, который должен быть запущен в двух
экземплярах:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[program:daemon]&lt;/span&gt;
&lt;span class="na"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;vdm&lt;/span&gt;
&lt;span class="na"&gt;command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/opt/bin/daemon-runner&lt;/span&gt;
&lt;span class="na"&gt;process_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;%(program_name)s_%(process_num)02d&lt;/span&gt;
&lt;span class="na"&gt;process_num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;2&lt;/span&gt;
&lt;span class="na"&gt;stdout_logfile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/var/log/%(program_name)s_%(process_num)02d.log&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;На мой взгляд это основная фишка supervisord - возможность запуска нескольких экземпляров демона без лишних телодвижений.
В том же runit для этого пришлось бы создать два отдельных сервиса с идентичными настройками, а в upstart - один сервис
привязанный к событию и нечто, что emit'ит это событие (идеально подходит для конфигурации сетевых интерфейсов,
но вот запуск просто демона получается слишком сложным (см. настройку сетевой подсистемы в Ubuntu)).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;Порядок запуска сервисов&lt;/h2&gt;
&lt;p&gt;После прочтения документации вам может показаться, что в supervisord самая вменяемая реализация порядка запуска сервисов.
Это не так.&lt;/p&gt;
&lt;p&gt;В supervisord каждому сервису можно задать приоритет (priority). Сервис с наивысшим приоритетом включается
последним и выключается первым. Кроме этого для сервиса можно указать параметр startsecs, который указывает
время в секундах, которое сервис должен прожить, что бы считаться успешно запущенным.&lt;/p&gt;
&lt;p&gt;Рассмотрим простой пример:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Конф. файл supervisord:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[program:service1]&lt;/span&gt;
&lt;span class="na"&gt;command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/opt/bin/service1&lt;/span&gt;
&lt;span class="na"&gt;priority&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;1&lt;/span&gt;
&lt;span class="na"&gt;startsecs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;10&lt;/span&gt;
&lt;span class="na"&gt;stdout_logfile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/tmp/service1.log&lt;/span&gt;

&lt;span class="k"&gt;[program:service2]&lt;/span&gt;
&lt;span class="na"&gt;command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/opt/bin/service2&lt;/span&gt;
&lt;span class="na"&gt;priority&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;100&lt;/span&gt;
&lt;span class="na"&gt;startsecs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;10&lt;/span&gt;
&lt;span class="na"&gt;stdout_logfile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/tmp/service2.log&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Сервисы:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@development:/opt/bin# cat service1
&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Start: $(date -R)&amp;quot;&lt;/span&gt;

&lt;span class="nb"&gt;exec &lt;/span&gt;dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/zero &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/null &lt;span class="nv"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1M
root@development:/opt/bin# cat service2
&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Start: $(date -R)&amp;quot;&lt;/span&gt;

&lt;span class="nb"&gt;exec &lt;/span&gt;dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/zero &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/null &lt;span class="nv"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;2M
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Самое логичное, что можно предположить - сервисы будут запускаться в следующем порядке:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Запуск service1;&lt;/li&gt;
&lt;li&gt;Ждем 10 секунд. Сервис работает. Считаем, что он запущен успешно;&lt;/li&gt;
&lt;li&gt;Запуск service2;&lt;/li&gt;
&lt;li&gt;Ждем 10 секунд. Сервис работает. Считаем, что он запущен успешно;&lt;/li&gt;
&lt;li&gt;Profit.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Что получаем на самом деле:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# tail -f /var/log/supervisor/supervisord.log
00:33:17,868 INFO spawned: &amp;#39;service1&amp;#39; with pid 6532
00:33:17,897 INFO spawned: &amp;#39;service2&amp;#39; with pid 6533
00:33:27,997 INFO success: service1 entered RUNNING state, process
 has stayed up for &amp;gt; than 10 seconds (startsecs)
00:33:27,997 INFO success: service2 entered RUNNING state, process
 has stayed up for &amp;gt; than 10 seconds (startsecs)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="web-interface"&gt;
&lt;h2&gt;Web-interface&lt;/h2&gt;
&lt;p&gt;Web интерфейс доступен &amp;quot;из коробки&amp;quot;. Позволяет:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Cмотреть статус сервисов;&lt;/li&gt;
&lt;li&gt;Смотреть лог сервиса;&lt;/li&gt;
&lt;li&gt;Очистить лог сервиса;&lt;/li&gt;
&lt;li&gt;Остановить/запустить сервис.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="events"&gt;
&lt;h2&gt;Events&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://supervisord.org/events.html"&gt;Документация на сайте проекта&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Event'ы еще одна значимая часть supervisord - позволяет реагировать на возникающие события (изменения статуса сервиса, новое сообщение в STDOUT/STDERR в логе сервиса и др. Полный список доступных событий - &lt;a class="reference external" href="http://supervisord.org/events.html#event-types"&gt;тут&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Примеры применения:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Послать письмо, если сервис упал;&lt;/li&gt;
&lt;li&gt;Послать изменение состояния в систему мониторинга;&lt;/li&gt;
&lt;li&gt;Перезапустить связанный сервис на этом или др. сервере (через XML-RPC).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Что бы начать реагировать на события необходимо настроить свой event-listener. Event-listener будет запущен supervisord как
дочерний процесс, а информация о событиях будет передаваться ему на STDIN, а через STDOUT он должен оповещать supervisord
о своем текущем статусе.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Пример настройки event-listener'а:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# cat /etc/supervisor/conf.d/listener.conf&lt;/span&gt;
&lt;span class="k"&gt;[eventlistener:watcher]&lt;/span&gt;
&lt;span class="na"&gt;command&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/opt/bin/watcher.py&lt;/span&gt;
&lt;span class="na"&gt;events&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;PROCESS_STATE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Пример event-listener'а:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;w&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flush&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;e&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flush&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;READY&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readline&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# debug&lt;/span&gt;
        &lt;span class="c"&gt;# parse line and do something&lt;/span&gt;
        &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;RESULT 2&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;OK&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;В STDERR event-listener'а при перезапуске service1 будет писаться следующее:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;processname:service1 groupname:service1 from_state:RUNNING pid:9915ver:3.0
server:supervisor01 serial:47 pool:watcher poolserial:7
eventname:PROCESS_STATE_STOPPED len:68
processname:service1 groupname:service1 from_state:STOPPING pid:9915ver:3.0
server:supervisor01 serial:48 pool:watcher poolserial:8
eventname:PROCESS_STATE_STARTING len:66
processname:service1 groupname:service1 from_state:STOPPED tries:0ver:3.0
server:supervisor01 serial:49 pool:watcher poolserial:9
eventname:PROCESS_STATE_RUNNING len:68
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h2&gt;Выводы&lt;/h2&gt;
&lt;p&gt;Вцелом supervisord выглядит как вменяемый законченный продукт (надо будет заняться исправлением поведения с порядком запуска
сервисов). Если сравнивать его со связкой &lt;a class="reference external" href="http://smarden.org/runit/"&gt;runit&lt;/a&gt; + &lt;a class="reference external" href="https://github.com/Undev/runit-man"&gt;runit-man&lt;/a&gt; он больше похож на то, что можно использовать в production
окружении. Но.. но основные достоинства supervisord просто бесполезны в случае использования chef:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Управление сервисами на удаленном сервере (через XML-RPC или supervisorctl -s SERVER_NAME). Вам это не надо, ведь у вас есть knife с поиском по ролям, нодам и тегам;&lt;/li&gt;
&lt;li&gt;Запуск нескольких инстансов демона без объявления нескольких сервисов. Опять же не особо полезно, ведь за вас эти сервисы настраивает chef. И сколько их 1, 10 или 100 вцелом не так уж и важно.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ссылки по теме:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://python.mirocommunity.org/video/1798/pyohio-2010-controlling-unix-p"&gt;Выступление Calvin Hendryx-Parker&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">HISTTIMEFORMAT</title>
    <id>http://verm666.github.com/2011/10/03/bash_history</id>
    <updated>2011-10-03T00:00:00Z</updated>
    <link href="http://verm666.github.com/2011/10/03/bash_history" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;Q: Как в history вывести время выполнения команды?&lt;/li&gt;
&lt;li&gt;A: Выставить значение переменной HISTTIMEFORMAT (в формате &lt;a class="reference external" href="http://www.manpagez.com/man/3/strftime/"&gt;strftime&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# export HISTTIMEFORMAT=&amp;quot;+%Y/%m/%d - %H:%M:%S % &amp;quot;
# history 3
    44  2011/10/03 - 16:27:55 % ls
    45  2011/10/03 - 16:27:59 % export HISTTIMEFORMAT=&amp;quot;%Y/%m/%d - %H:%M:%S % &amp;quot;
    46  2011/10/03 - 16:28:01 % history 3
&lt;/pre&gt;&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">Python Bookmarks</title>
    <id>http://verm666.github.com/2011/09/20/python_bookmarks</id>
    <updated>2011-09-20T00:00:00Z</updated>
    <link href="http://verm666.github.com/2011/09/20/python_bookmarks" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;div class="section" id="books"&gt;
&lt;h2&gt;Books&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;David M. Beazley - Python Essential Reference, 4th Edition&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="gil"&gt;
&lt;h2&gt;GIL&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;David M. Beazley - PyCon 2010:Understanding the Python GIL (#82) - &lt;a class="reference external" href="http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2010-understanding-the-python-gil-82-3273690"&gt;http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2010-understanding-the-python-gil-82-3273690&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://verm666.github.com/feed.atom">
    <title type="text">Memory as a programming concept in C and C++</title>
    <id>http://verm666.github.com/2011/09/09/memory_as_a_programming_concept</id>
    <updated>2011-09-09T00:00:00Z</updated>
    <link href="http://verm666.github.com/2011/09/09/memory_as_a_programming_concept" />
    <author>
      <name>verm666</name>
    </author>
    <content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;Название книги: Memory as a Programming Concept in C and C++&lt;/li&gt;
&lt;li&gt;Автор: Frantisek Franek&lt;/li&gt;
&lt;li&gt;Amazon: &lt;a class="reference external" href="http://www.amazon.com/Memory-Programming-Concept-Frantisek-Franek/dp/0521520436"&gt;http://www.amazon.com/Memory-Programming-Concept-Frantisek-Franek/dp/0521520436&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>

