<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
  
    <title> | verm666's blog</title>
    <link href="http://fonts.googleapis.com/css?family=Vollkorn&subset=latin" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/static/style.css" type="text/css">
    <link href="/feed.atom" rel="alternate" title="Recent Blog Posts" type="application/atom+xml">
    <link rel="stylesheet" href="/static/_pygments.css" type="text/css">
  
  </head>
  <body>
    <div class=container>
      <div class=header>
        <a href="/">verm666</a>'s blog
      </div>
      <div class=navigation>
        <ul>
          <li><a href="/">blog</a>
          <li><a href="/archive/">archive</a>
          <li><a href="/tags/">tags</a>
        </ul>
      </div>
      <div class=body>
      
  
  
  <p class=date>written on Tuesday, March 20, 2012
  

  <div class="section" id="nginx">
<h2>Nginx. Что нового?</h2>
<div class="section" id="disable-symlinks">
<h3>disable_symlinks</h3>
<ul class="simple">
<li>модуль: ngx_http_core_module</li>
<li>офф. описание: <a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_core_module.html#disable_symlinks">ngx_http_core_module.html#disable_symlinks</a></li>
</ul>
<p>Директива определяет как вести себя с символическими ссылками при открытии
файла. Офф. описания более чем достаточно, что бы понять как этим пользоваться.</p>
<p>Если честно, сейчас я не вижу какого-то реального применения этой директивы,
особенно с учетом того, что в модуле ngx_http_autoindex_module эта директива
игнорируется, а ведь именно там порой и хочется странного. Ждем.</p>
</div>
<div class="section" id="proxy-cookie-domain">
<h3>proxy_cookie_domain</h3>
<ul class="simple">
<li>модуль: ngx_http_proxy_module</li>
<li>офф. описание: <a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_proxy_module.html#proxy_cookie_domain">ngx_http_proxy_module.html#proxy_cookie_domain</a></li>
</ul>
<p>Директива позволяет подменять domain в Cookie в ответе от бэкенда. По сути
такой аналог proxy_redirect только для Cookie.</p>
</div>
<div class="section" id="so-keepalive">
<h3>so_keepalive</h3>
<ul class="simple">
<li>модуль: ngx_http_core_module</li>
<li>офф. описание: <a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_core_module.html#listen">ngx_http_core_module.html#listen</a></li>
</ul>
<p>Возможность переопределить след. пареметры из sysctl:</p>
<ul class="simple">
<li>tcp_keepalive_time</li>
<li>tcp_keepalive_intvl</li>
<li>tcp_keepalive_probes</li>
</ul>
<p>и вкл/выкл SO_KEEPALIVE на сокете.</p>
</div>
<div class="section" id="https-if-not-empty">
<h3>$https и if_not_empty</h3>
<ul class="simple">
<li>модуль: ngx_http_core_module</li>
<li>офф. описание: <a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_core_module.html#variables">ngx_http_core_module.html#variables</a></li>
</ul>
<p>Используется в fastcgi/uwsgi/etc_params совместно с новой директивой
if_not_empty, так как в случае http соединения - значением переменной
будет пустая строка. Польза от новой переменной очевидная и банальная -
простой и удобный интерфейс для выставления еще одной переменной (HTTPS)
в параметрах запроса к бэкенду. Раньше наверное это можно было нагородить
из if и переменной $scheme.</p>
</div>
<div class="section" id="proxy-redirect">
<h3>proxy_redirect с переменными и регулярными выражениями</h3>
<ul class="simple">
<li>модуль: ngx_http_proxy_module</li>
<li>офф. описание: <a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_proxy_module.html#proxy_redirect">ngx_http_proxy_module.html#proxy_redirect</a></li>
</ul>
<p>Теперь в первом аргументе proxy_redirect можно использовать переменные и
регулярные выражения (причем с capture groups). Теперь можно строить еще более
извращенные динамические правила. Неописуемый восторг.</p>
</div>
<div class="section" id="keepalive-upstream">
<h3>keepalive в соединении к upstream</h3>
<ul class="simple">
<li>модуль: ngx_http_upstream_module</li>
<li>офф. описание: <a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_upstream_module.html#keepalive">ngx_http_upstream_module.html#keepalive</a></li>
</ul>
<p>Работает это так:</p>
<ul class="simple">
<li>Создаем upstream с keepalive 10;</li>
<li>Делаем первый запрос, который уходит на этот upstream;</li>
<li>После выполнения запроса TCP соединение остается жить (state: ESTABLISHED);</li>
<li>Делаем 100 параллельных подключений. В это время к upstream будет установлено
100 соединений. После выполнения всех 100 запросов - 10 останется в ESTABLISED
состоянии. Лишние соединения закрываются.</li>
</ul>
<p>Чуть подробнее об особенностях этих соединений:</p>
<ul class="simple">
<li>Кол-во персистентных соединений указывается для всех серверов в группе. Т.е.
если у вас три сервера в группе и значение keepalive равно 30, то эти 30
соединений будут распределены между тремя серверами в группе.</li>
<li>Соединения распределяются неравномерно по серверам в группе. Сколько
соединений устанавливается к каждому серверу группы зависит напрямую от того
на какой из группы приходили последние соединения, т.к. заркываются наиболее
старые лишние соединения независимо от того, на один сервер из группы они
пришли или на разные. Это очень хорошо видно, если один сервер из группы
отвечает на запросы быстрее остальных. К такому серверу будет меньше (или
вообще не будет) соединений.</li>
</ul>
<p>Польза от данной директивы очевидная: мы не теряем время на TCP handshake.
Разница должна хорошо ощущаться при переносе проекта на др. хостинг с proxy_pass
на старом.</p>
<p>Для fastcgi есть аналогичная директива - <a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_fastcgi_module.html#fastcgi_keep_conn">fastcgi_keep_conn</a>
.</p>
</div>
<div class="section" id="proxy-cache-lock">
<h3>proxy_cache_lock</h3>
<ul class="simple">
<li>модуль: ngx_http_proxy_module</li>
<li>офф. описание: <a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_proxy_module.html#proxy_cache_lock">ngx_http_proxy_module.html#proxy_cache_lock</a></li>
</ul>
<p>Об этой директиве я уже вскользь упоминал в <a class="reference external" href="http://verm666.name/2012/03/17/xxx_farm/">предыдущем посте</a>. Позволяет удерживать одновременные
запросы к бэкенду и отдавать всем клиентам ответ полученный от первого запроса.</p>
<p>Приемущества:</p>
<ul class="simple">
<li>Если обработка запросом бэкенда является дорогой (долгой) операцией, то
использование данной директивы очень упростит вам жизнь. Простой пример
- HTTP Live Streaming, когда бэкенд генерирует плейлисты и видео файлы для
этих плейлистов.</li>
</ul>
<p>Минусы:</p>
<ul class="simple">
<li>В случае проблем с ушедшим на бэкенд запросом (потеряный SYN, ретрансмит
пакета), ответ от которого ждут все клиенты - появится дополнительная
задержка для каждого клиента.</li>
</ul>
</div>
</div>
<div class="section" id="id2">
<h2>Выводы</h2>
<ul class="simple">
<li>Nginx 0.7 и текущая версия - это 2 довольно различных продукта;</li>
<li>Настоятельно рекомендую читать то, что пишется в CHANGES;</li>
<li>Если вы считаете, что последняя ветка нестабильна - вы неправы.
Сайт проекта webvybory2012.ru работал на 1.1.14 с минимальными изменениями.
Полет был нормальный;</li>
</ul>
</div>
<div class="section" id="p-s">
<h2>P.S.</h2>
<p>Почему мало кто знает про <a class="reference external" href="http://nginx.org/ru/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors">proxy_intercept_errors</a></p>
</div>


  

      </div>
      <div class=footer>
          <a href="http://twitter.com/verm666">twitter</a>,
          <a href="http://github.com/verm666">github</a>,
          <a href="/feed.atom" rel="alternate" title="Recent Blog Posts">feed</a>
      </div>
    </div>
  </body>
</html>
